import React, { useState, useEffect } from 'react';
import getMergeSortAnims from '../../sortingAlgorithms/mergeSort.js';
import getQuickSortAnims from '../../sortingAlgorithms/quickSort.js';
import getHeapSortAnims from '../../sortingAlgorithms/heapSort.js';
import getBubbleSortAnims from '../../sortingAlgorithms/bubbleSort.js';
import runAnimation, { runMSAnimation } from './AnimationHandler.js';
import Navigation from '../nav/Navigation';
import './SortingVisualizer.css';

function SortingVisualizer() {

    // State variables

    const [sorting, setSorting] = useState(false);
    const [sortingArr, setSortingArr] = useState([]);
    const [sortingState, setSortingState] = useState("merge-sort");

    // Hooks for starting sorting and generating a new array on load

    useEffect(() => {
        if (sorting) runSort();  
    });

    useEffect(() => {
        generateArray();
    }, []);

    // Handles run button click action

    function handleRun() { 
        setSorting(true);
    };

    // Generate a new 200 element array with random values from 3 to 98
    // Update state array

    function generateArray() {
        const arr = [];
        for(let i = 0; i < 200; i++) {
            arr.push(randomInt(3, 98));
        }
        setSortingArr(arr);
    };

    // Run the algorithm corresponding to the current sorting state

    function runSort() {
        if(sortingState === "merge-sort")
            runMergeSort();
        else if(sortingState === "quick-sort")
            runQuickSort();
        else if(sortingState === "heap-sort")
            runHeapSort();
        else if(sortingState === "bubble-sort")
            runBubbleSort();
    };

    // Functions to run and create animations for the specified sorting algorithms

     function runMergeSort() {
        const animSpeed = 18;
        const anims = getMergeSortAnims(sortingArr);
        runMSAnimation(anims, animSpeed);
        startResetTimer(anims, animSpeed);
    } 

    function runQuickSort() {
        const animSpeed = 18;
        const anims = getQuickSortAnims(sortingArr, 0, sortingArr.length - 1);
        runAnimation(anims, animSpeed);
        startResetTimer(anims, animSpeed);
    }

    function runHeapSort() {
        const animSpeed = 18;
        const anims = getHeapSortAnims(sortingArr);
        runAnimation(anims, animSpeed);
        startResetTimer(anims, animSpeed);
    }

    function runBubbleSort() {
        const animSpeed = 2;
        const anims = getBubbleSortAnims(sortingArr);
        runAnimation(anims, animSpeed);
        startResetTimer(anims, animSpeed);
    }

    // Reset timer resets the screen buttoms after the sorting algorithm animations are completed

    function startResetTimer(anims, timeIncrements){
        setTimeout(() => {
            setSorting(false);
        }, anims.length * timeIncrements + 600);
    }

    // arrayBars generated by mapping the values in the current states sorting array

    const arrayBars = (
        sortingArr.map((value, idx) => (
            <div className="array-bar" 
                key={idx}
                style={{height: `${value}%`}}>
            </div>
        ))
    );

    // Render

    return (
        <div>
            <Navigation 
                refresh={generateArray}
                updateState={setSortingState}
                busy={sorting}
                run={handleRun}
            />
            <div className="main-nav">
            <h1>Selected Algorithm: {sortingState}</h1>
                <div className="array-container">
                    {arrayBars}
                </div>
            </div>
        </div>
    );
}

// Generate a random integer between the value of min and max

function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min +  1) + min)
} 

export default SortingVisualizer;
